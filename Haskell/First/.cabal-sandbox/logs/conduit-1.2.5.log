Configuring conduit-1.2.5...
Building conduit-1.2.5...
Preprocessing library conduit-1.2.5...
[1 of 8] Compiling Data.Conduit.Internal.Pipe ( Data/Conduit/Internal/Pipe.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/Pipe.o )

Data/Conduit/Internal/Pipe.hs:48:1: Warning:
    The import of ‘Control.Applicative’ is redundant
      except perhaps to import instances from ‘Control.Applicative’
    To import instances alone, use: import Control.Applicative()

Data/Conduit/Internal/Pipe.hs:60:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()
[2 of 8] Compiling Data.Conduit.Internal.Conduit ( Data/Conduit/Internal/Conduit.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/Conduit.o )

Data/Conduit/Internal/Conduit.hs:86:1: Warning:
    Module ‘Prelude’ does not export ‘catch’

Data/Conduit/Internal/Conduit.hs:87:1: Warning:
    The import of ‘Control.Applicative’ is redundant
      except perhaps to import instances from ‘Control.Applicative’
    To import instances alone, use: import Control.Applicative()

Data/Conduit/Internal/Conduit.hs:100:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()

Data/Conduit/Internal/Conduit.hs:107:1: Warning:
    The import of ‘Data.Traversable’ is redundant
      except perhaps to import instances from ‘Data.Traversable’
    To import instances alone, use: import Data.Traversable()
[3 of 8] Compiling Data.Conduit.Internal.Fusion ( Data/Conduit/Internal/Fusion.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/Fusion.o )
[4 of 8] Compiling Data.Conduit.Internal.List.Stream ( Data/Conduit/Internal/List/Stream.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/List/Stream.o )
[5 of 8] Compiling Data.Conduit.Internal ( Data/Conduit/Internal.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal.o )
[6 of 8] Compiling Data.Conduit     ( Data/Conduit.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit.o )
[7 of 8] Compiling Data.Conduit.List ( Data/Conduit/List.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/List.o )

Data.Conduit.List:1:1: Warning:
    Orphan rule: "conduit: $$ foldM" [ALWAYS] forall @ (m :: * -> *)
                                                     @ b
                                                     @ a21
                                                     $dMonad :: Monad m
                                                     $dMonad1 :: Monad m
                                                     src :: Source m a21
                                                     f :: b -> a21 -> m b
                                                     b1 :: b
                   $$ @ m
                      @ a21
                      @ b
                      $dMonad
                      src
                      (unstream
                         @ a21
                         @ Data.Void.Void
                         @ m
                         @ b
                         (Data.Conduit.Internal.Fusion.ConduitWithStream
                            @ a21
                            @ Data.Void.Void
                            @ m
                            @ b
                            (let {
                               $dApplicative :: Prelude.Applicative
                                                  (ConduitM a21 Data.Void.Void m)
                               = Data.Conduit.Internal.Conduit.$fApplicativeConduitM
                                   @ a21
                                   @ Data.Void.Void
                                   @ m
                                   (Data.Conduit.Internal.Conduit.$fFunctorConduitM
                                      @ a21
                                      @ Data.Void.Void
                                      @ m)
                             } in
                             letrec {
                               loop :: b -> ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                               = \ accum :: b ->
                                 let {
                                   f1 :: ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                                   = Data.Conduit.Internal.Conduit.$fMonadConduitM_$creturn
                                       @ a21
                                       @ Data.Void.Void
                                       @ m
                                       $dApplicative
                                       @ b
                                       accum
                                 } in
                                 $ @ (forall b2.
                                      (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                      -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                   @ (ConduitM a21 Data.Void.Void m b)
                                   (\ tpl :: forall b2.
                                             (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                             -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    tpl)
                                     `cast`
                                   (<forall b2.
                                     (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                     -> CI.Pipe a21 a21 Data.Void.Void () m b2>_R
                                    ->_R Sym (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                                                  <a21>_N <Data.Void.Void>_N <m>_N <b>_R))
                                   (\ @ b2 rest :: b -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    Data.Conduit.Internal.Pipe.NeedInput
                                      @ a21
                                      @ a21
                                      @ Data.Void.Void
                                      @ ()
                                      @ m
                                      @ b2
                                      (\ i1 :: a21 ->
                                       CI.unConduitM
                                         @ a21
                                         @ Data.Void.Void
                                         @ m
                                         @ b
                                         @ b2
                                         (Data.Conduit.Internal.Conduit.$fMonadConduitM_$c>>=
                                            @ a21
                                            @ Data.Void.Void
                                            @ m
                                            $dApplicative
                                            @ b
                                            @ b
                                            ($ @ (m b)
                                               @ (ConduitM a21 Data.Void.Void m b)
                                               (Data.Conduit.Internal.Conduit.$fMonadBasebaseConduitM_$clift
                                                  @ a21
                                                  @ Data.Void.Void
                                                  @ m
                                                  @ b
                                                  $dMonad1)
                                               (f accum i1))
                                            (\ accum' :: b ->
                                             case accum' of accum'1 { DEFAULT -> loop accum'1 }))
                                         rest)
                                      ($ @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         @ (() -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         (Prelude.const
                                            @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                            @ ())
                                         (CI.unConduitM
                                            @ a21
                                            @ Data.Void.Void
                                            @ m
                                            @ b
                                            @ b2
                                            f1
                                            rest)))
                             } in
                             loop b1)
                            (foldMS @ b @ a21 @ m $dMonad1 f b1 @ Data.Void.Void)))
                   = letrec {
                       go :: CI.Pipe () () a21 () m () -> b -> m b {- Arity: 2 -}
                       = \ ds :: CI.Pipe () () a21 () m () b2 :: b ->
                         case ds of wild {
                           CI.HaveOutput src1 ds1 a22
                           -> >>=
                                @ m
                                $dMonad1
                                @ b
                                @ b
                                (f b2 a22)
                                (\ b' :: b -> case b' of b'1 { DEFAULT -> go src1 b'1 })
                           CI.NeedInput ds1 c -> go (c ghc-prim-0.4.0.0:GHC.Tuple.()) b2
                           CI.Done ds1
                           -> case ds1 of wild1 { () -> return @ m $dMonad1 @ b b2 }
                           CI.PipeM msrc
                           -> >>=
                                @ m
                                $dMonad1
                                @ (CI.Pipe () () a21 () m ())
                                @ b
                                msrc
                                (\ src1 :: CI.Pipe () () a21 () m () -> go src1 b2)
                           CI.Leftover src1 ds1 -> case ds1 of wild1 { () -> go src1 b2 } }
                     } in
                     go
                       (src
                          `cast`
                        (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                             <()>_N <a21>_N <m>_N <()>_R)
                          @ ()
                          (Data.Conduit.Internal.Pipe.Done @ () @ () @ a21 @ () @ m @ ()))
                       b1

Data.Conduit.List:1:1: Warning:
    Orphan rule: "conduit: $$ fold" [ALWAYS] forall @ (m :: * -> *)
                                                    @ b
                                                    @ a21
                                                    $dMonad :: Monad m
                                                    $dMonad1 :: Monad m
                                                    src :: Source m a21
                                                    f :: b -> a21 -> b
                                                    b1 :: b
                   $$ @ m
                      @ a21
                      @ b
                      $dMonad
                      src
                      (unstream
                         @ a21
                         @ Data.Void.Void
                         @ m
                         @ b
                         (Data.Conduit.Internal.Fusion.ConduitWithStream
                            @ a21
                            @ Data.Void.Void
                            @ m
                            @ b
                            (let {
                               $dApplicative :: Prelude.Applicative
                                                  (ConduitM a21 Data.Void.Void m)
                               = Data.Conduit.Internal.Conduit.$fApplicativeConduitM
                                   @ a21
                                   @ Data.Void.Void
                                   @ m
                                   (Data.Conduit.Internal.Conduit.$fFunctorConduitM
                                      @ a21
                                      @ Data.Void.Void
                                      @ m)
                             } in
                             letrec {
                               loop :: b -> ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                               = \ accum :: b ->
                                 case accum of accum1 { DEFAULT ->
                                 let {
                                   f1 :: ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                                   = Data.Conduit.Internal.Conduit.$fMonadConduitM_$creturn
                                       @ a21
                                       @ Data.Void.Void
                                       @ m
                                       $dApplicative
                                       @ b
                                       accum1
                                 } in
                                 let {
                                   g :: a21 -> b = f accum1
                                 } in
                                 $ @ (forall b2.
                                      (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                      -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                   @ (ConduitM a21 Data.Void.Void m b)
                                   (\ tpl :: forall b2.
                                             (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                             -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    tpl)
                                     `cast`
                                   (<forall b2.
                                     (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                     -> CI.Pipe a21 a21 Data.Void.Void () m b2>_R
                                    ->_R Sym (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                                                  <a21>_N <Data.Void.Void>_N <m>_N <b>_R))
                                   (\ @ b2 rest :: b -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    Data.Conduit.Internal.Pipe.NeedInput
                                      @ a21
                                      @ a21
                                      @ Data.Void.Void
                                      @ ()
                                      @ m
                                      @ b2
                                      (\ i1 :: a21 ->
                                       CI.unConduitM
                                         @ a21
                                         @ Data.Void.Void
                                         @ m
                                         @ b
                                         @ b2
                                         (loop (g i1))
                                         rest)
                                      ($ @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         @ (() -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         (Prelude.const
                                            @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                            @ ())
                                         (CI.unConduitM
                                            @ a21
                                            @ Data.Void.Void
                                            @ m
                                            @ b
                                            @ b2
                                            f1
                                            rest))) }
                             } in
                             loop b1)
                            (foldS @ b @ a21 @ m $dMonad1 f b1 @ Data.Void.Void)))
                   = letrec {
                       go :: CI.Pipe () () a21 () m () -> b -> m b {- Arity: 2 -}
                       = \ ds :: CI.Pipe () () a21 () m () b2 :: b ->
                         case ds of wild {
                           CI.HaveOutput src1 ds1 a22
                           -> Prelude.$! @ b @ (m b) (go src1) (f b2 a22)
                           CI.NeedInput ds1 c -> go (c ghc-prim-0.4.0.0:GHC.Tuple.()) b2
                           CI.Done ds1
                           -> case ds1 of wild1 { () -> return @ m $dMonad1 @ b b2 }
                           CI.PipeM msrc
                           -> >>=
                                @ m
                                $dMonad1
                                @ (CI.Pipe () () a21 () m ())
                                @ b
                                msrc
                                (\ src1 :: CI.Pipe () () a21 () m () -> go src1 b2)
                           CI.Leftover src1 ds1 -> case ds1 of wild1 { () -> go src1 b2 } }
                     } in
                     go
                       (src
                          `cast`
                        (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                             <()>_N <a21>_N <m>_N <()>_R)
                          @ ()
                          (Data.Conduit.Internal.Pipe.Done @ () @ () @ a21 @ () @ m @ ()))
                       b1
[8 of 8] Compiling Data.Conduit.Lift ( Data/Conduit/Lift.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Lift.o )

Data/Conduit/Lift.hs:74:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()

Data/Conduit/Lift.hs:77:1: Warning:
    Module ‘Control.Monad.Trans.Error’ is deprecated:
      Use Control.Monad.Trans.Except instead

Data/Conduit/Lift.hs:128:26: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:128:56: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:130:29: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:133:12: Warning:
    In the use of data constructor ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:139:16: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:140:20: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:145:25: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:150:56: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:159:16: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:160:20: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:161:29: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:162:23: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:167:32: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"
[1 of 8] Compiling Data.Conduit.Internal.Pipe ( Data/Conduit/Internal/Pipe.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/Pipe.p_o )

Data/Conduit/Internal/Pipe.hs:48:1: Warning:
    The import of ‘Control.Applicative’ is redundant
      except perhaps to import instances from ‘Control.Applicative’
    To import instances alone, use: import Control.Applicative()

Data/Conduit/Internal/Pipe.hs:60:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()
[2 of 8] Compiling Data.Conduit.Internal.Conduit ( Data/Conduit/Internal/Conduit.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/Conduit.p_o )

Data/Conduit/Internal/Conduit.hs:86:1: Warning:
    Module ‘Prelude’ does not export ‘catch’

Data/Conduit/Internal/Conduit.hs:87:1: Warning:
    The import of ‘Control.Applicative’ is redundant
      except perhaps to import instances from ‘Control.Applicative’
    To import instances alone, use: import Control.Applicative()

Data/Conduit/Internal/Conduit.hs:100:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()

Data/Conduit/Internal/Conduit.hs:107:1: Warning:
    The import of ‘Data.Traversable’ is redundant
      except perhaps to import instances from ‘Data.Traversable’
    To import instances alone, use: import Data.Traversable()
[3 of 8] Compiling Data.Conduit.Internal.Fusion ( Data/Conduit/Internal/Fusion.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/Fusion.p_o )
[4 of 8] Compiling Data.Conduit.Internal.List.Stream ( Data/Conduit/Internal/List/Stream.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal/List/Stream.p_o )
[5 of 8] Compiling Data.Conduit.Internal ( Data/Conduit/Internal.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Internal.p_o )
[6 of 8] Compiling Data.Conduit     ( Data/Conduit.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit.p_o )
[7 of 8] Compiling Data.Conduit.List ( Data/Conduit/List.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/List.p_o )

Data.Conduit.List:1:1: Warning:
    Orphan rule: "conduit: $$ foldM" [ALWAYS] forall @ (m :: * -> *)
                                                     @ b
                                                     @ a21
                                                     $dMonad :: Monad m
                                                     $dMonad1 :: Monad m
                                                     src :: Source m a21
                                                     f :: b -> a21 -> m b
                                                     b1 :: b
                   $$ @ m
                      @ a21
                      @ b
                      $dMonad
                      src
                      (unstream
                         @ a21
                         @ Data.Void.Void
                         @ m
                         @ b
                         (Data.Conduit.Internal.Fusion.ConduitWithStream
                            @ a21
                            @ Data.Void.Void
                            @ m
                            @ b
                            (let {
                               $dApplicative :: Prelude.Applicative
                                                  (ConduitM a21 Data.Void.Void m)
                               = Data.Conduit.Internal.Conduit.$fApplicativeConduitM
                                   @ a21
                                   @ Data.Void.Void
                                   @ m
                                   (Data.Conduit.Internal.Conduit.$fFunctorConduitM
                                      @ a21
                                      @ Data.Void.Void
                                      @ m)
                             } in
                             letrec {
                               loop :: b -> ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                               = \ accum :: b ->
                                 let {
                                   f1 :: ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                                   = Data.Conduit.Internal.Conduit.$fMonadConduitM_$creturn
                                       @ a21
                                       @ Data.Void.Void
                                       @ m
                                       $dApplicative
                                       @ b
                                       accum
                                 } in
                                 $ @ (forall b2.
                                      (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                      -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                   @ (ConduitM a21 Data.Void.Void m b)
                                   (\ tpl :: forall b2.
                                             (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                             -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    tpl)
                                     `cast`
                                   (<forall b2.
                                     (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                     -> CI.Pipe a21 a21 Data.Void.Void () m b2>_R
                                    ->_R Sym (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                                                  <a21>_N <Data.Void.Void>_N <m>_N <b>_R))
                                   (\ @ b2 rest :: b -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    Data.Conduit.Internal.Pipe.NeedInput
                                      @ a21
                                      @ a21
                                      @ Data.Void.Void
                                      @ ()
                                      @ m
                                      @ b2
                                      (\ i1 :: a21 ->
                                       CI.unConduitM
                                         @ a21
                                         @ Data.Void.Void
                                         @ m
                                         @ b
                                         @ b2
                                         (Data.Conduit.Internal.Conduit.$fMonadConduitM_$c>>=
                                            @ a21
                                            @ Data.Void.Void
                                            @ m
                                            $dApplicative
                                            @ b
                                            @ b
                                            ($ @ (m b)
                                               @ (ConduitM a21 Data.Void.Void m b)
                                               (Data.Conduit.Internal.Conduit.$fMonadBasebaseConduitM_$clift
                                                  @ a21
                                                  @ Data.Void.Void
                                                  @ m
                                                  @ b
                                                  $dMonad1)
                                               (f accum i1))
                                            (\ accum' :: b ->
                                             case accum' of accum'1 { DEFAULT -> loop accum'1 }))
                                         rest)
                                      ($ @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         @ (() -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         (Prelude.const
                                            @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                            @ ())
                                         (CI.unConduitM
                                            @ a21
                                            @ Data.Void.Void
                                            @ m
                                            @ b
                                            @ b2
                                            f1
                                            rest)))
                             } in
                             loop b1)
                            (foldMS @ b @ a21 @ m $dMonad1 f b1 @ Data.Void.Void)))
                   = letrec {
                       go :: CI.Pipe () () a21 () m () -> b -> m b {- Arity: 2 -}
                       = \ ds :: CI.Pipe () () a21 () m () b2 :: b ->
                         case ds of wild {
                           CI.HaveOutput src1 ds1 a22
                           -> >>=
                                @ m
                                $dMonad1
                                @ b
                                @ b
                                (f b2 a22)
                                (\ b' :: b -> case b' of b'1 { DEFAULT -> go src1 b'1 })
                           CI.NeedInput ds1 c -> go (c ghc-prim-0.4.0.0:GHC.Tuple.()) b2
                           CI.Done ds1
                           -> case ds1 of wild1 { () -> return @ m $dMonad1 @ b b2 }
                           CI.PipeM msrc
                           -> >>=
                                @ m
                                $dMonad1
                                @ (CI.Pipe () () a21 () m ())
                                @ b
                                msrc
                                (\ src1 :: CI.Pipe () () a21 () m () -> go src1 b2)
                           CI.Leftover src1 ds1 -> case ds1 of wild1 { () -> go src1 b2 } }
                     } in
                     go
                       (src
                          `cast`
                        (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                             <()>_N <a21>_N <m>_N <()>_R)
                          @ ()
                          (Data.Conduit.Internal.Pipe.Done @ () @ () @ a21 @ () @ m @ ()))
                       b1

Data.Conduit.List:1:1: Warning:
    Orphan rule: "conduit: $$ fold" [ALWAYS] forall @ (m :: * -> *)
                                                    @ b
                                                    @ a21
                                                    $dMonad :: Monad m
                                                    $dMonad1 :: Monad m
                                                    src :: Source m a21
                                                    f :: b -> a21 -> b
                                                    b1 :: b
                   $$ @ m
                      @ a21
                      @ b
                      $dMonad
                      src
                      (unstream
                         @ a21
                         @ Data.Void.Void
                         @ m
                         @ b
                         (Data.Conduit.Internal.Fusion.ConduitWithStream
                            @ a21
                            @ Data.Void.Void
                            @ m
                            @ b
                            (let {
                               $dApplicative :: Prelude.Applicative
                                                  (ConduitM a21 Data.Void.Void m)
                               = Data.Conduit.Internal.Conduit.$fApplicativeConduitM
                                   @ a21
                                   @ Data.Void.Void
                                   @ m
                                   (Data.Conduit.Internal.Conduit.$fFunctorConduitM
                                      @ a21
                                      @ Data.Void.Void
                                      @ m)
                             } in
                             letrec {
                               loop :: b -> ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                               = \ accum :: b ->
                                 case accum of accum1 { DEFAULT ->
                                 let {
                                   f1 :: ConduitM a21 Data.Void.Void m b {- Arity: 1 -}
                                   = Data.Conduit.Internal.Conduit.$fMonadConduitM_$creturn
                                       @ a21
                                       @ Data.Void.Void
                                       @ m
                                       $dApplicative
                                       @ b
                                       accum1
                                 } in
                                 let {
                                   g :: a21 -> b = f accum1
                                 } in
                                 $ @ (forall b2.
                                      (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                      -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                   @ (ConduitM a21 Data.Void.Void m b)
                                   (\ tpl :: forall b2.
                                             (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                             -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    tpl)
                                     `cast`
                                   (<forall b2.
                                     (b -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                     -> CI.Pipe a21 a21 Data.Void.Void () m b2>_R
                                    ->_R Sym (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                                                  <a21>_N <Data.Void.Void>_N <m>_N <b>_R))
                                   (\ @ b2 rest :: b -> CI.Pipe a21 a21 Data.Void.Void () m b2 ->
                                    Data.Conduit.Internal.Pipe.NeedInput
                                      @ a21
                                      @ a21
                                      @ Data.Void.Void
                                      @ ()
                                      @ m
                                      @ b2
                                      (\ i1 :: a21 ->
                                       CI.unConduitM
                                         @ a21
                                         @ Data.Void.Void
                                         @ m
                                         @ b
                                         @ b2
                                         (loop (g i1))
                                         rest)
                                      ($ @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         @ (() -> CI.Pipe a21 a21 Data.Void.Void () m b2)
                                         (Prelude.const
                                            @ (CI.Pipe a21 a21 Data.Void.Void () m b2)
                                            @ ())
                                         (CI.unConduitM
                                            @ a21
                                            @ Data.Void.Void
                                            @ m
                                            @ b
                                            @ b2
                                            f1
                                            rest))) }
                             } in
                             loop b1)
                            (foldS @ b @ a21 @ m $dMonad1 f b1 @ Data.Void.Void)))
                   = letrec {
                       go :: CI.Pipe () () a21 () m () -> b -> m b {- Arity: 2 -}
                       = \ ds :: CI.Pipe () () a21 () m () b2 :: b ->
                         case ds of wild {
                           CI.HaveOutput src1 ds1 a22
                           -> Prelude.$! @ b @ (m b) (go src1) (f b2 a22)
                           CI.NeedInput ds1 c -> go (c ghc-prim-0.4.0.0:GHC.Tuple.()) b2
                           CI.Done ds1
                           -> case ds1 of wild1 { () -> return @ m $dMonad1 @ b b2 }
                           CI.PipeM msrc
                           -> >>=
                                @ m
                                $dMonad1
                                @ (CI.Pipe () () a21 () m ())
                                @ b
                                msrc
                                (\ src1 :: CI.Pipe () () a21 () m () -> go src1 b2)
                           CI.Leftover src1 ds1 -> case ds1 of wild1 { () -> go src1 b2 } }
                     } in
                     go
                       (src
                          `cast`
                        (Data.Conduit.Internal.Conduit.NTCo:ConduitM[0]
                             <()>_N <a21>_N <m>_N <()>_R)
                          @ ()
                          (Data.Conduit.Internal.Pipe.Done @ () @ () @ a21 @ () @ m @ ()))
                       b1
[8 of 8] Compiling Data.Conduit.Lift ( Data/Conduit/Lift.hs, dist/dist-sandbox-5bf6cc0d/build/Data/Conduit/Lift.p_o )

Data/Conduit/Lift.hs:74:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()

Data/Conduit/Lift.hs:77:1: Warning:
    Module ‘Control.Monad.Trans.Error’ is deprecated:
      Use Control.Monad.Trans.Except instead

Data/Conduit/Lift.hs:128:26: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:128:56: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:130:29: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:133:12: Warning:
    In the use of data constructor ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:139:16: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:140:20: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:145:25: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:150:56: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:159:16: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:160:20: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:161:29: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:162:23: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:167:32: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"
In-place registering conduit-1.2.5...
Running Haddock for conduit-1.2.5...
Preprocessing library conduit-1.2.5...

Data/Conduit/Internal/Pipe.hs:48:1: Warning:
    The import of ‘Control.Applicative’ is redundant
      except perhaps to import instances from ‘Control.Applicative’
    To import instances alone, use: import Control.Applicative()

Data/Conduit/Internal/Pipe.hs:60:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()

Data/Conduit/Internal/Conduit.hs:86:1: Warning:
    Module ‘Prelude’ does not export ‘catch’

Data/Conduit/Internal/Conduit.hs:87:1: Warning:
    The import of ‘Control.Applicative’ is redundant
      except perhaps to import instances from ‘Control.Applicative’
    To import instances alone, use: import Control.Applicative()

Data/Conduit/Internal/Conduit.hs:100:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()

Data/Conduit/Internal/Conduit.hs:107:1: Warning:
    The import of ‘Data.Traversable’ is redundant
      except perhaps to import instances from ‘Data.Traversable’
    To import instances alone, use: import Data.Traversable()

Data/Conduit/Lift.hs:74:1: Warning:
    The import of ‘Data.Monoid’ is redundant
      except perhaps to import instances from ‘Data.Monoid’
    To import instances alone, use: import Data.Monoid()

Data/Conduit/Lift.hs:77:1: Warning:
    Module ‘Control.Monad.Trans.Error’ is deprecated:
      Use Control.Monad.Trans.Except instead

Data/Conduit/Lift.hs:128:26: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:128:56: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:130:29: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:133:12: Warning:
    In the use of data constructor ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:139:16: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:140:20: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:145:25: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:150:56: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:159:16: Warning:
    In the use of type constructor or class ‘E.Error’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:160:20: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:161:29: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:162:23: Warning:
    In the use of type constructor or class ‘E.ErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

Data/Conduit/Lift.hs:167:32: Warning:
    In the use of ‘E.runErrorT’
    (imported from Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"
Haddock coverage:
  91% ( 32 / 35) in 'Data.Conduit.Internal.Pipe'
  Missing documentation for:
    Module header
    yieldM (Data/Conduit/Internal/Pipe.hs:256)
    enumFromTo (Data/Conduit/Internal/Pipe.hs:502)
  93% ( 68 / 73) in 'Data.Conduit.Internal.Conduit'
  Missing documentation for:
    Module header
    yieldM (Data/Conduit/Internal/Conduit.hs:803)
    sourceToPipe (Data/Conduit/Internal/Conduit.hs:330)
    sinkToPipe (Data/Conduit/Internal/Conduit.hs:340)
    conduitToPipe (Data/Conduit/Internal/Conduit.hs:350)
  19% (  3 / 16) in 'Data.Conduit.Internal.Fusion'
  Missing documentation for:
    Module header
    Stream (Data/Conduit/Internal/Fusion.hs:36)
    ConduitWithStream (Data/Conduit/Internal/Fusion.hs:40)
    StreamConduitM (Data/Conduit/Internal/Fusion.hs:44)
    StreamConduit (Data/Conduit/Internal/Fusion.hs:46)
    StreamSource (Data/Conduit/Internal/Fusion.hs:48)
    StreamProducer (Data/Conduit/Internal/Fusion.hs:50)
    StreamSink (Data/Conduit/Internal/Fusion.hs:52)
    StreamConsumer (Data/Conduit/Internal/Fusion.hs:54)
    streamConduit (Data/Conduit/Internal/Fusion.hs:173)
    streamSource (Data/Conduit/Internal/Fusion.hs:179)
    streamSourcePure (Data/Conduit/Internal/Fusion.hs:197)
    unstream (Data/Conduit/Internal/Fusion.hs:56)
   0% (  0 / 39) in 'Data.Conduit.Internal.List.Stream'
  Missing documentation for:
    Module header
    unfoldS (Data/Conduit/Internal/List/Stream.hs:12)
    unfoldMS (Data/Conduit/Internal/List/Stream.hs:25)
    sourceListS (Data/Conduit/Internal/List/Stream.hs:39)
    enumFromToS (Data/Conduit/Internal/List/Stream.hs:47)
    enumFromToS_int (Data/Conduit/Internal/List/Stream.hs:59)
    iterateS (Data/Conduit/Internal/List/Stream.hs:73)
    replicateS (Data/Conduit/Internal/List/Stream.hs:82)
    replicateMS (Data/Conduit/Internal/List/Stream.hs:91)
    foldS (Data/Conduit/Internal/List/Stream.hs:100)
    foldMS (Data/Conduit/Internal/List/Stream.hs:112)
    mapM_S (Data/Conduit/Internal/List/Stream.hs:126)
    dropS (Data/Conduit/Internal/List/Stream.hs:140)
    takeS (Data/Conduit/Internal/List/Stream.hs:155)
    headS (Data/Conduit/Internal/List/Stream.hs:170)
    mapS (Data/Conduit/Internal/List/Stream.hs:182)
    mapMS (Data/Conduit/Internal/List/Stream.hs:194)
    iterMS (Data/Conduit/Internal/List/Stream.hs:206)
    mapMaybeS (Data/Conduit/Internal/List/Stream.hs:218)
    mapMaybeMS (Data/Conduit/Internal/List/Stream.hs:233)
    catMaybesS (Data/Conduit/Internal/List/Stream.hs:249)
    concatS (Data/Conduit/Internal/List/Stream.hs:262)
    concatMapS (Data/Conduit/Internal/List/Stream.hs:275)
    concatMapMS (Data/Conduit/Internal/List/Stream.hs:288)
    concatMapAccumS (Data/Conduit/Internal/List/Stream.hs:303)
    mapAccumS (Data/Conduit/Internal/List/Stream.hs:318)
    mapAccumMS (Data/Conduit/Internal/List/Stream.hs:332)
    concatMapAccumMS (Data/Conduit/Internal/List/Stream.hs:346)
    mapFoldableS (Data/Conduit/Internal/List/Stream.hs:361)
    mapFoldableMS (Data/Conduit/Internal/List/Stream.hs:374)
    consumeS (Data/Conduit/Internal/List/Stream.hs:389)
    groupByS (Data/Conduit/Internal/List/Stream.hs:401)
    groupOn1S (Data/Conduit/Internal/List/Stream.hs:405)
    GroupByState (Data/Conduit/Internal/List/Stream.hs:409)
    groupBy1S (Data/Conduit/Internal/List/Stream.hs:414)
    isolateS (Data/Conduit/Internal/List/Stream.hs:435)
    filterS (Data/Conduit/Internal/List/Stream.hs:448)
    sinkNullS (Data/Conduit/Internal/List/Stream.hs:461)
    sourceNullS (Data/Conduit/Internal/List/Stream.hs:473)
  94% (104 /111) in 'Data.Conduit.Internal'
  Missing documentation for:
    Module header
    yieldM (Data/Conduit/Internal/Pipe.hs:256)
    enumFromTo (Data/Conduit/Internal/Pipe.hs:502)
    yieldM (Data/Conduit/Internal/Conduit.hs:803)
    sourceToPipe (Data/Conduit/Internal/Conduit.hs:330)
    sinkToPipe (Data/Conduit/Internal/Conduit.hs:340)
    conduitToPipe (Data/Conduit/Internal/Conduit.hs:350)
 100% ( 74 / 74) in 'Data.Conduit'
 100% ( 52 / 52) in 'Data.Conduit.List'
  98% ( 43 / 44) in 'Data.Conduit.Lift'
  Missing documentation for:
    distribute (Data/Conduit/Lift.hs:118)
Documentation created: dist/dist-sandbox-5bf6cc0d/doc/html/conduit/index.html
Creating package registration file:
/var/folders/jv/m80d3qfn5tz4qyfrtyq42kc00000gn/T/pkgConf-conduit-1.27079531781509658266.5
Installing library in
/Users/katsuya/study/Haskell/First/.cabal-sandbox/lib/x86_64-osx-ghc-7.10.2/conduit-1.2.5-9wHaNJrxyyq9dFXfK2u9W6
Registering conduit-1.2.5...
